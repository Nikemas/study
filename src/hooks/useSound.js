import { useCallback, useState, useEffect } from 'react';

// Simple short beep/chime sounds in base64
// Note: In a production app, these should be real asset files
const SOUND_ASSETS = {
    // Soft pop/message sound
    message: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU',
    // Achievement/Unlock chime
    unlock: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU',
    // Success/Correct answer
    success: 'data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU',
};

// NOTE: The above are just placeholders headers. 
// I will use slightly more realistic short sounds if possible, 
// or simple beeps generated by Web Audio API if I were using it.
// For now, let's use a real simplistic approach: 
// Since I can't easily generate valid long base64 strings here without bloating the context,
// I will simulate the sound playing or use a very very short valid WAV header which might just click.
// Ideally the user would provide files. 
// I will stick to the plan: "Simple synthesized sounds/base64".
// Let's rely on the user replacing these or use a library later.
// However, to make it "work" without error, I will define a helper that could use Web Audio API for synthetic beeps.

const createBeep = (frequency = 440, duration = 0.1, type = 'sine') => {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();

        oscillator.type = type;
        oscillator.frequency.value = frequency;

        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);

        oscillator.start();
        oscillator.stop(audioContext.currentTime + duration);
    } catch (error) {
        console.warn('Audio play failed', error);
    }
};

export const useSound = () => {
    const [enabled, setEnabled] = useState(() => {
        return localStorage.getItem('sound_enabled') !== 'false';
    });

    const toggleSound = useCallback(() => {
        setEnabled(prev => {
            const newValue = !prev;
            localStorage.setItem('sound_enabled', String(newValue));
            return newValue;
        });
    }, []);

    const playSound = useCallback((type) => {
        if (!enabled) return;

        // Use Web Audio API for synthetic sounds to ensure they work without external files
        switch (type) {
            case 'message':
                createBeep(800, 0.1, 'sine');
                break;
            case 'receive':
                createBeep(600, 0.15, 'sine');
                break;
            case 'unlock':
                // A little arpeggio for unlock
                setTimeout(() => createBeep(523.25, 0.1), 0);
                setTimeout(() => createBeep(659.25, 0.1), 100);
                setTimeout(() => createBeep(783.99, 0.3), 200);
                break;
            case 'success':
                createBeep(1000, 0.2, 'sine');
                break;
            case 'error':
                createBeep(200, 0.3, 'sawtooth');
                break;
            default:
                createBeep(440, 0.1);
        }
    }, [enabled]);

    return { enabled, toggleSound, playSound };
};
